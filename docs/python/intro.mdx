---
id: intro
title: Introducción
sidebar_position: 1 
---

:::info Enlace de utilidad
[Web oficial de Python](https://www.python.org/)

[Documentación de Python](https://docs.python.org/3/)
:::

## ¿Qué es Python?
Es un lenguaje de programación de código abierto, orientado a objetos, simple y fácil de entender. Tiene una sintaxis sencilla que cuenta con una vasta biblioteca de herramientas. 
Es un lenguaje interpretado con **tipado dinámico**, **multiparadigma** y **multiplataforma**.

## Principales usos
* Inteligencia artificial
* Big Data
* Data Science
* Frameworks de pruebas
* Desarrollo Web
* Bots :heart_eyes:
* Etc

## Tipos de número
Python distingue entre **enteros (int - long)**, **números de punto flotante (float)** y **números complejos (complex)**. A diferencia de otros lenguajes de programación, los números
**tipo int** en Python 3 pueden ser pequeños o grandes, no tienen límite alguno.

:::note Nota
Los números complejos son los que tienen parte imaginaria y es muy probable que no lo vayas a necesitar nunca. Se almacenan usando reales, ya que es una extensión de dichos números.
:::

## Cadena de texto
Las cadenas o **strings (str)** son un tipo de dato compuesto por secuencias de caracteres que representan texto. Estas cadenas se delimitan
mediante el uso de comillas simples o dobles.

:::note Ejemplo
"Esto es una cadena de texto"

'Esto es una cadena de texto también'

"""
También esto es una cadena de texto
"""
:::

:::caution
Los Strings sin **inmutables**, esto significa que no podemos sustituir ninguno de sus caracteres individualmente.
:::



## Variables
Las variables se pueden entender como "cajas" en las que se guardan datos, pero en Python las variables son "**etiquetas**" que permiten 
hacer referencias a los datos (que se guardan en "cajas" llamadas objetos).

Python es un lenguaje de programación **orientado a objetos** y su modelo de datos también está basado en objetos.
:::caution Atención
Python es **case-sensitive**. Por lo que va a distinguir las mayúsculas y minúsculas de las variables.
:::

Para cada dato que aparece en un programa, Python crea un objeto que lo contiene. Cada objeto tiene:
* Un **identificador único** (un número entero, distinto para cada objeto). Esto permite a Python referirse al objeto sin ambigüedades.
* Un **tipo de datos** (entero, decimal, etc.) Esto le permite saber qué operaciones puede hacerse con el dato.
* Un **valor** (el propio dato).

## Precedencia
El orden normal de las operaciones es de **izquierda a derecha**, evaluando en orden los siguientes operadores:

* Términos entre paréntesis
* Potenciación y raíces
* Multiplicación y división
* Suma y resta


## Print / Input
Gracias a la función **print()** podemos mostrar de forma correcta las cadenas de texto (u otros objetos) en pantalla.
:::note Ejemplo
```py 
# Comilla simple
print('Hola Mundo')

# Comilla doble
print("Hola Mundo")

# Agregar un template string
print("""Primera línea
Segunda línea""")
```
:::

Para recibir datos del exterior usamos la función **input()**, la cual nos permite obtener texto escrito por teclado. Al llegar
el programa a dicha función, se detiene esperando que el usuario escriba algo y pulse la tecla **Intro**.

:::caution Atención
De forma predeterminada, **input() convierte la entrada en una cadena**, aunque en ella escribamos un número. Si necesitamos convertir este valor
a un entero, debemos utilizar la función **int()**

```py
year = int(input('¿En qué año estamos?'))
```
:::

:::note Ejemplo
```py
# Sin argumento
nombre = input()
print(nombre)

# Con argumento
nombre = input('¿Cómo te llamas?')
print(nombre)
```
:::

## Indexación de strings
Cada uno de los caracteres de una cadena (en donde se incluyen los espacios y símbolos especiales), tienen asignado un índice.
Este nos permite seleccionar su carácter asociado haciendo referencia a él entre corchetes en la variable que lo almacena.

El **índice comienza en 0** para el primer carácter y en caso de buscar el **último corresponde al -1**.

## Len
Así como tenemos ```print()``` para mostrar información en pantalla e ```input()``` para obtener datos externos, Python nos brinda
otra función para conocer la longitud de los Strings llamada len().

```py
nombre = 'Brian'
print(len(nombre))
>>> 5
```

## Slice
Es una función que nos permite seleccionar una parte de la cadena en base a la notación ```[inicio:fin:paso]```.

**Inicio**:
Es el índice del primer carácter de la porción de la cadena que queremos seleccionar.

**Fin**:
Es el índice del último carácter no incluido de la porción de la cadena que queremos seleccionar.

**Paso**:
Indica cuántos caracteres seleccionamos entre las posiciones de inicio y fin.

```py 
cadena = 'Python'
print(cadena[2:6:2])
>>> to

cadena = 'Python'
print(cadena[0:4:1])
>>> Pyth
```

:::tip Ayudita
Si utilizamos **[::-1]** sobre una cadena de texto, esta nos retorna la cadena al revés. 

```py
cadena = “acitámetaM ,5.8 ,otipeP ordeP”
cadena_reverse = cadena[::-1]
print(cadena_reverse)
>>>Pedro Pepito, 8.5, Matemática
```
:::

## Listas y Tuplas
Las listas son un tipo de dato que nos permite almacenar variables, números, cadenas de textos, otras listas, etc. 
Dichos valores, deben estar separados por comas dentro de los corchetes.

Al igual que los Strings las listas tienen un índice y se puede utilizar el slicing para recorrerlos con la ventaja de que, en este caso, si **podemos
modificar los valores de sus índices ya que las listas son mutables**.

```py
# Consulta por Slicing
lista = [10, 'Pedro', '3', 4]
print(lista[-2:])
>>> ['3',4]

# Modificación por Slicing
letras = ['a','b','c','d','e','f']
letras[:3] = ['A','B','C']
print(letras)
>>> ['A', 'B', 'C', 'd', 'e', 'f']

# Borrado por Slicing
letras[:3] = []
print(letras)
>>> ['d', 'e', 'f']
```

**Las tuplas** son similares a las listas, con la diferencia de que estas **son inmutables**, por lo que no podremos modificarlas
una vez instanciadas.

### Funciones de listas

#### append()
Nos permite agregar un nuevo ítem al **final** de una lista. 

```py
letras = []
letras.append('a')
letras.append('b')
print(letras)
>>> ['a', 'b']
```

#### pop()
Al contrario de append(), en este caso nos permite eliminar el último ítem de la lista.

```py
letras = ['a', 'b','c','d']
letras.pop()
print(letras)
>>> ['a', 'b','c']

letras.pop(0)
print(letras)
>>> [ 'b','c']
```

#### count()
Nos permite contar cuantas veces nuestro ítem se repite en la lista.

```py
numeros = [1,1,3,2,5,2,1]
print(numeros.count(1))
>>> 3
```

#### index()
Nos permite buscar nuestro ítem y nos retorna el índice en el que se encuentra. En caso de haber 
varios valores iguales, **solo nos retornará el primero que encuentre**.

```py
letras = ['a','b','c','a']
print(letras.index('a'))
>>> 0
```

:::caution Atención
Si se intenta buscar un valor fuera de lista, retornará un error.
:::

#### list()
Convierte un iterable en una lista.
```py
vocales = 'aeiou'
print(list(vocales))
>>> ['a','e','i','o','u']
```

## Condicionales

### If / Elif / Else
Al utilizar el condicional **if** le indicamos a Python que queremos ejecutar una porción de código
siempre y cuando se cumplan las condiciones dadas. 

De no cumplirse la primera condición, **elif** nos permite hacer lo mismo ampliando más las condiciones posibles.

Y, en el caso de que ninguna condición sea verdadera, se ejecutará el **else** como porción de código por defecto.

```py
A = 30
if A < 10:
    print('Es menor a 10')
elif A < 15:
    print('Es menor a 15')
elif A < 20:
    print('Es menor a 20')
else:
    print('Es mayor a 20')
```

## Iteraciones

### While
Nos permite repetir un fragmento de código mientras una condición lógica sea Verdadera.

```py
num = 0
while num <= 3:
    print(num) 
    num += 1

# El else dentro del while nos permite ejecutar una porción de código cuando se cumple la condición del while.
chance  = 1
while chance <= 3:
  txt = input("Escribe SI: ")
  if txt == "SI":
     print("Ok, lo conseguiste en el intento", chance)
     break
  chance += 1
else:
  print("Has agotado tus tres intentos")

```

#### break
Con esta instrucción podemos cortar la ejecución de nuestro bucle.

#### continue
Con esta instrucción vamos a poder volver al inicio del bucle.

#### pass
La utilizaremos cuando queramos crear una clase, método, función, bucle o condicional, pero en el que todavía no queramos definir ningún comportamiento por lo que le
indica al programa que ignore esa condición y continúe ejecutando el programa como de costumbre

### For
Se utiliza para recorrer un objeto iterable, como una lista o tupla y ejecutar una porción de código sobre ellos.

```py
lista = [1,2,3,4,5]
for valor in lista:
    print('Soy un ítem de la lista y valgo', valor)

### range(inicio,fin,pasos)
for valor in range(10,40,2):
    print('Soy un ítem de la lista y valgo', valor)

```
## Conjuntos
Es una colección no ordenada de objetos únicos (no hay elementos duplicados). En ellos se nos permite
guardar enteros, cadenas de texto y variables de forma homogenea y heterogenea pero no objetos mutables (listas, diccionarios u otros 
conjuntos). 

Si bien son mutables como las listas, una diferencia con ellas es que en los conjuntos **no podemos
utilizar slicing ni manejar índices**.

```py
numeros = {1,2,3,4}
palabras = {"Hola", "como", "estas", "?"}
heterogeneo = {1, 2, "Hola", 4}
conjunto_vacio = set()
```
### Funciones de conjuntos

#### set()
Convierte un iterable a un conjunto.
```py
vocales = ['a','e','i','o','u']
mi_set = set(vocales)
print(mi_set)
>>> ['a','e','i','o','u']
```

#### add()
Nos permite agregar un nuevo ítem al conjunto así como también realizar operaciones aritméticas
dentro de este.

```py
numeros = {1,2,3,4}
numeros.add(5)
numeros.add(3*2)
print(numeros)
>>> {1, 2, 3, 4, 5, 6}
```

#### update()
Nos sirve para insertar múltiples elementos iterables (tuplas, string, listas, etc).

```py
numeros = {1,2,3,4}
numeros.update([5,6,7,8])
numeros.update(range(9,12))
print(numeros)
>>> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
```

#### len()
Nos ayuda a saber la longitud de nuestro conjunto.

#### discard()
Nos permite descartar un valor dentro del conjunto, en caso de que dicho valor no exista se omite la operación.

```py
numeros = {1,2,3,4}
numeros.discard(2)
numeros.discard(10)
print(numeros)
>>> {1, 3, 4}
```

#### remove()
Es similar al discard, pero en caso de que no exista el valor a remover nos arroja un error.

#### in()
Nos sirve para saber si un valor se encuentra dentro de nuestro conjunto.

```py
numeros = {1,2,3,4}
print(2 in numeros)
>>> True
print(10 in numeros)
>>> False
```

#### clear()
Nos sirve para eliminar todos los valores del conjunto.

```py
numeros = {1,2,3,4}
numeros.clear()
print(numeros)
>>> set()
```

#### pop()
Remueve del conjunto el primer elemento.

```py
numeros = {1,2,3,4}
numeros.pop()
numeros.pop()
print(numeros)
>>> {3, 4}
```

## Diccionarios
Es una colección no ordenada de objetos (no posee un índice) la cúal para identificar un elementro
dentro de esta se utiliza una **clave** y su contenido es el **valor**. Podemos modificar sus valores ingresando
desde su clave.

```py
colores = {"amarillo": "yellow", "azul": "blue"}
print(colores["amarillo"])
>>> yellow

colores["azul"] = "orange"
print(colores["azul"])
>>> orange
```

Si necesitamos agregar nuevos valores al diccionario, basta con agregarlos de la siguiente manera:
```py
colores = {"amarillo": "yellow", "azul": "blue"}
colores["rojo"] = "red"
print(colores)
>>> {'amarillo': 'yellow', 'azul': 'blue', 'rojo': 'red'}

colores.update("verde": "green", "negro": "black")
print(colores)
>>> 
```

También contaremos con las funciones de:
* len
* del
* in
* update

## Funciones
## Manejo de archivos